<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (1.8.0_121) on Thu Mar 30 16:43:16 CEST 2017 -->
<title>dreisoft.tresos.generator.ng.api.cds (Public API Documentation)</title>
<meta name="date" content="2017-03-30">
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="dreisoft.tresos.generator.ng.api.cds (Public API Documentation)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../../dreisoft/tresos/generator/ng/api/ant/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../../dreisoft/tresos/generator/ng/api/cds/abstraction/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../../index.html?dreisoft/tresos/generator/ng/api/cds/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;dreisoft.tresos.generator.ng.api.cds</h1>
<div class="docSummary">
<div class="block">C Data Structure Generator (CDS)

    The CDS generator is part of the new generator api.</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../dreisoft/tresos/generator/ng/api/cds/CDSGenFile.html" title="class in dreisoft.tresos.generator.ng.api.cds">CDSGenFile</a></td>
<td class="colLast">
<div class="block">Virtual file for the CDS generator.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../dreisoft/tresos/generator/ng/api/cds/CDSGenScope.html" title="class in dreisoft.tresos.generator.ng.api.cds">CDSGenScope</a></td>
<td class="colLast">
<div class="block">Writing types and vars to a <a href="../../../../../../dreisoft/tresos/generator/ng/api/cds/CDSGenFile.html" title="class in dreisoft.tresos.generator.ng.api.cds"><code>CDSGenFile</code></a> always requires an active <code>CDSGenScope</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../dreisoft/tresos/generator/ng/api/cds/CDSGenScope.Attribute.html" title="class in dreisoft.tresos.generator.ng.api.cds">CDSGenScope.Attribute</a></td>
<td class="colLast">
<div class="block">Super class of scope attributes.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Exception Summary table, listing exceptions, and an explanation">
<caption><span>Exception Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Exception</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../../dreisoft/tresos/generator/ng/api/cds/CDSGenAPIException.html" title="class in dreisoft.tresos.generator.ng.api.cds">CDSGenAPIException</a></td>
<td class="colLast">
<div class="block">This API exception is thrown if there were API usage errors within the cds generator.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../../dreisoft/tresos/generator/ng/api/cds/CDSGenException.html" title="class in dreisoft.tresos.generator.ng.api.cds">CDSGenException</a></td>
<td class="colLast">Deprecated
<div class="block"><span class="deprecationComment">this exception is only for internal errors</span></div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package dreisoft.tresos.generator.ng.api.cds Description">Package dreisoft.tresos.generator.ng.api.cds Description</h2>
<div class="block"><h2>C Data Structure Generator (CDS)</h2>
<p>
    The CDS generator is part of the new generator api. It provides
    functionality to generate type and variable definitions from Java objects
    into the C language. This is necessary for link-time and post-build
    parameters that need to be generated after the pre-compile phase.
</p>

<h3>Features</h3>
<p>
    The following features are supported:
</p>
<ul>
    <li>Primitive types, pointers, structs and arrays</li>
    <li>Creating typedefs</li>
    <li>Writing variable initializations of built-in and self-defined types</li>
    <li>Null-Pointer and function pointer support</li>
    <li>Compiler abstraction</li>
    <li>Memory abstraction</li>
    <li>Comments for each variable and member</li>
    <li>Volatile modifier</li>
    <li>Conditional members within structs</li>
</ul>

<h3>The engine classes</h3>
<p>
    The CDS generator mainly consists of a few classes that are described next.
    For examples go to <a href="#examples">Examples</a> section.
</p>

<h4>CDSGenEngine</h4>
<p>
    This class is the starting point of a CDS generation where you start a new
    CDSGenFile using a given backend. It is not intended to be instantiated
    directly but is retrieved through the public field cds of class
    JavaGenContext. To see how to get a JavaGenContext please refer to the
    general documentation of the new generator api.
</p>

<h4>CDSGenFile</h4>
<p>
    The CDSGenFile is the class you will deal most with because it provides
    methods to start and stop CDSGenScopes, generate typedefs and variable
    definitions. As described above the CDSGenFile is created by calling one of
    CDSGenEngine's startFile methods where you must specify an ICDSEngineBackend
    implementation that will be used with it. After CDSGenEngine's endFile
    method was called it is not possible to write to the file anymore.
</p>

<h4>ICDSEngineBackend</h4>
<p>
    The interface that a backend for the CDS generator must implement. In order
    to start a CDSGenFile you have to instantiate a backend that fits your
    needs. Currently known backends are:
</p>
<table border="1" width="100%">
    <colgroup>
        <col />
        <col />
    </colgroup>
    <tr>
        <td>CBackend</td>
        <td>It generates pure readable C code.</td>
    </tr>
</table>

<h4>CDSGenScope</h4>
<p>
    Writing to a CDSGenFile always requires an active scope. If you do not
    started a scope explicitly by calling one of the CDSGenFile's startScope
    methods then a default scope is automatically started at your first write
    attempt. There can only be one active scope per file at one time so the
    active one must be closed (endScope) first before a new one can start. The
    code generation is manipulated by the scope's attributes, e.g. memory
    abstraction.
</p>

<h3>Overview of CTypes</h3>
<p>
    There are several built-in C types that can either be used directly to
    generate variable initializations or can be subclassed to generate own
    typedefs and variables of it.
</p>
<table border="1" width="100%">
    <colgroup>
        <col style="width:60px; vertical-align:top;" />
        <col style="width:90px; vertical-align:top;" />
        <col style="width:80px; vertical-align:top;" />
        <col />
    </colgroup>
    <tr>
        <td><a href="ctypes/CType.html">CType</a></td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>The abstract base class of all C types for this generator. Every
            CType must have a name but it is not always necessary to specify one
            explicitly (see ComplexType). Furthermore every CType can have a
            comment and can make use of compiler abstraction.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td><a href="ctypes/PrimitiveType.html">PrimitiveType</a></td>
        <td>&nbsp;</td>
        <td>The abstract base class of all primitive types of the C language.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td><a href="ctypes/SInt8.html">SInt8</a></td>
        <td>Represents a signed 8-bit integer in the C language.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td><a href="ctypes/SInt16.html">SInt16</a></td>
        <td>Represents a signed 16-bit integer in the C language.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td><a href="ctypes/SInt32.html">SInt32</a></td>
        <td>Represents a signed 32-bit integer in the C language.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td><a href="ctypes/UInt8.html">UInt8</a></td>
        <td>Represents an unsigned 8-bit integer in the C language.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td><a href="ctypes/UInt16.html">UInt16</a></td>
        <td>Represents an unsigned 16-bit integer in the C language.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td><a href="ctypes/UInt32.html">UInt32</a></td>
        <td>Represents an unsigned 32-bit integer in the C language.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td><a href="ctypes/ComplexType.html">ComplexType</a></td>
        <td>&nbsp;</td>
        <td>The abstract base class of all complex types in the C language.
            Every member or element of a complex type automatically retrieves
            its name by the enclosing complex type and it is not allowed to
            change the name manually.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td><a href="ctypes/Array.html">Array</a></td>
        <td>Represents an array consisting of various number of elements of the
            generic type T that in turn must be an instance of CType. To create
            multi-dimensional arrays an array can consist of further arrays. The
            length of an array is determined by its elements. The Array class is
            final and can't be subclassed because it's not allowed to define
            types of array in the C language.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td><a href="ctypes/Struct.html">Struct</a></td>
        <td>The abstract base class of all structs. To create a struct in the C
            language it is necessary to subclass Struct and define members as
            public fields of various type (instance of CType). It is necessary
            to call super.init() at end of the constructor to initialize the
            members. Thus it is not allowed to reassign members it is best
            practice to define each member final until a member should be
            declared with the volatile modifier in the resulting code generation
            output.<br/>If the struct implements the
            <a href="ctypes/IConditionalMembers.html">IConditionalMembers</a>
            interface then it is able to skip the generation of particular
            members. This is done with the callback method exists(String) that
            asks for each member with the given name and expects a boolean value
            if the member should be generated or not. Make sure that the
            implementation returns the same result for both typedef and
            variables.<br/>
            In general, the members of structs are written in their natural order
            in which they appear in the Struct class. By assigning an
            <a href="IMemberSorter.html">IMemberSorter</a> to a Struct instance using 
            method <code>setMemberSorter(IMemberSorter)</code> the order of the
            members depends on the implementation of the sorter. To use the same
            sorter for any struct within a <a href="../CDSGenScope.html">CDSGenScope</a>
            you can add a <a href="CTypeDescriptors.html">CTypeDescriptors</a> scope
            attribute and set a default member sorter with
            <code>CTypeDescriptors.setDefaultMemberSorter(IMemberSorter)</code>.
        </td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td><a href="ctypes/Ptr.html">Ptr</a></td>
        <td>&nbsp;</td>
        <td>Represents a pointer to the generic type T that in turn must be an
            instance of CType. It is possible to create pointer to pointer (and
            so on) but it is recommended to create typedefs of each pointer to
            avoid nested compiler abstractions. A pointer always needs a
            prototype of the referenced type to generate valid C code for it.
            Normally the prototype will be the referenced object itself but when
            creating a null pointer it must be defined explicitly while the
            referenced object is null.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td><a href="ctypes/PBPtr.html">PBPtr</a></td>
        <td>&nbsp;</td>
        <td>This subclass of Ptr represents a post-buildable pointer. It is
            final and can only be used directly. The PBPtr always uses compiler
            abstraction and special macros for assignment.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td><a href="ctypes/Function.html">Function</a></td>
        <td>&nbsp;</td>
        <td>Function is a description of a C function to generate pointers to
            functions. It is not possible to generate code for the function
            itself. So it only knows the name, parameters and return type of a
            function that must be defined elsewhere.</td>
    </tr>
</table>

<h3 id="examples">Examples</h3>
<p>
    Please see the documentation of the new generator api if you do not know how
    to write your own generator. It is assumed that you have already a valid
    JavaGenContext instance for the following samples. The code snippets show 
    both Java sources and the resulting C output. The C output is marked with an
    equals sign (=) at the beginning of each line.
</p>

<h4>Starting a CDSGenFile</h4>
<p>
    The CDSGenEngine is accessible through the public field cds of the
    JavaGenContext and provides methods to start a file. These methods always
    require a valid CBackend instance to be used with the returned file. If the
    file is omitted then the default file from the context will be used. Note
    that this sample generates no code but is the base of the following
    examples.
</p>
<pre>
    public void generate( JavaGenContext context ) {
        CDSGenFile cdsFile;
        try {
            cdsFile = context.cds.startFile( new CBackend() );
        } catch( IOException e ) {
            throw new IllegalStateException( "Unable to start default file", e );
        }

        // ... write types and variables

        context.cds.startFile( cdsFile );
    }
</pre>

<h4>Starting and ending a CDSGenScope</h4>
<p>
    A default scope without attributes does not generate code and is started and
    ended with methods startScope() and endScope() of CDSGenFile or implicit at
    the first attempt to write typedefs or variables. Thus there can exist only
    one active scope at a time the endScope method always referes to the last
    started scope and doesn't take any parameters. Starting a scope with
    attributes like memory abstraction can either generate code immediately or
    can affect the code generation within the scope.
</p>
<pre>
    cdsFile.startScope( new MemAbstraction( "EEP_START_SEC_VAR_16BIT", "EEP_STOP_SEC_VAR_16BIT" ) );

=   #define EEP_START_SEC_VAR_16BIT
=   #include "MemMap.h"

    cdsFile.endScope();

=   #define EEP_STOP_SEC_VAR_16BIT
=   #include "MemMap.h"
</pre>

<h4>Writing some variables of built-in types</h4>
<p>
    As mentioned above built-in types can only be used directly to generate
    variables and not to generate typedefs because they are already known.
    Variables are written by method <code>CDSGenFile.var(CType)</code>.
</p>

<h4>Integer variable</h4>
<p>
    The following example writes a simple SInt32 with name "a" and value 123456.
    Because it's a standalone variable (a top-level element, not member or
    element of a ComplexType) it needs a name that must be specified via the
    constructor and can't be changed anymore. Note that the name <i>sint_a</i>
    of the local variable in the Java code doesn't affect the C output. The
    value of integral types is always nested within a respective macro, here
    SINT32_C.
</p>
<pre>
    SInt32 sint_a = new SInt32( "a", 123456 );
    cdsFile.var( sint_a );

=   /**
=    * a
=    */
=   sint32 a = SINT32_C( 123456 );
</pre>

<h4>Integer variable with compiler abstraction</h4>
<p>
    The next example generates another SInt32 with name b. It makes use of
    compiler abstraction which generates a macro around the variable's type
    sint32. Take a short look at the CompilerAbstraction constructor.
    <code>true</code> means that the variable is constant and the generated
    macro is CONST, otherwise it would be VAR. The memory class AUTOMATIC is
    default and hence the shorter constructor
    <code>new CompilerAbstraction( true )</code> would do it just as well here.
    Another comfortable fact to mention is that most setter methods of CType
    classes return the CType (this) and can be called one by one.
</p>
<pre>
    SInt32 b = new SInt32( "b", 2 );
    b.setCompilerAbstraction( new CompilerAbstraction( true, "AUTOMATIC" ) )
     .setComment( "this var uses compiler abstraction." );

    cdsFile.var( b );

=   /**
=    * b
=    */
=   CONST( sint32, AUTOMATIC ) b = SINT32_C( 2 ); /* this var uses compiler abstraction. */
</pre>

<h4>Array of integer</h4>
<p>
    The generic type of Array defines the element type that the array consists
    of. Adding different types or null to the array is not allowed. Class Array
    provides various functions to add elements to the array. Remember that Array
    is a subclass of ComplexType and the elements retrieve their name
    automatically by the enclosing type. So never use the constructor with name
    for the creation of the elements. Furthermore the array length depends on
    the number of added elements (in this case 4) and can not be changed.
</p>
<pre>
    Array&lt;SInt16&gt; ramChips = new Array&lt;SInt16&gt;( "ramChips" ).add( new SInt16( 512 ) )
                                                            .add( new SInt16( 1024 ) )
                                                            .add( new SInt16( 2048 ) )
                                                            .add( new SInt16( 4096 ) );
    cdsFile.var( ramChips );

=   /**
=    * ramChips
=    */
=   sint16 ramChips[4] = {
=       SINT16_C( 512 ), /* [0] */
=       SINT16_C( 1024 ), /* [1] */
=       SINT16_C( 2048 ), /* [2] */
=       SINT16_C( 4096 )  /* [3] */
=   };
</pre>

<h4>2-dimensional integer array</h4>
<p>
    As already said it is possible to generate multi-dimensional arrays by
    nesting arrays in arrays.
</p>
<pre>
    Array&lt;Array&lt;UInt8&gt;&gt; int2d = new Array&lt;Array&lt;UInt8&gt;&gt;( "i2d" )
        .add( new Array&lt;UInt8&gt;().add( new UInt8( 11 ) )
                                .add( new UInt8( 12 ) )
                                .add( new UInt8( 13 ) )
                                .add( new UInt8( 14 ) )
                                .add( new UInt8( 15 ) ) )
        .add( new Array&lt;UInt8&gt;().add( new UInt8( 21 ) )
                                .add( new UInt8( 22 ) )
                                .add( new UInt8( 23 ) )
                                .add( new UInt8( 24 ) )
                                .add( new UInt8( 25 ) ) );

    cdsFile.var( int2d );

=   /**
=    * i2d
=    */
=   uint8 i2d[2][5] = {
=       { /* [0] */
=           UINT8_C( 11 ), /* [0] */
=           UINT8_C( 12 ), /* [1] */
=           UINT8_C( 13 ), /* [2] */
=           UINT8_C( 14 ), /* [3] */
=           UINT8_C( 15 )  /* [4] */
=       },
=       { /* [1] */
=           UINT8_C( 21 ), /* [0] */
=           UINT8_C( 22 ), /* [1] */
=           UINT8_C( 23 ), /* [2] */
=           UINT8_C( 24 ), /* [3] */
=           UINT8_C( 25 )  /* [4] */
=       }
=   };
</pre>

<h4>Pointer to integer</h4>
<p>
    The generic type of Ptr defines the type the pointer points to. The creation
    of a pointer is as simple as the creation of the pointed integer <i>a</i>
    (as described above). It needs a name because it's a top-level element and
    gets the instance of the referenced object <i>a</i> into its constructor.
    Note that the used constructor is not intended to create null pointer and
    that the referenced object may not be null here.
</p>
<pre>
    Ptr&lt;SInt32&gt; p2a = new Ptr&lt;SInt32&gt;( "p2a", a );
    cdsFile.var( p2a );

=   /**
=    * p2a
=    */
=   sint32 *p2a = &a;
</pre>

<h4>Pointer to integer with compiler abstraction</h4>
<p>
    The only thing new in this example is the fact that you have to define the
    pointer class for the compiler abstraction (second parameter in the
    CompilerAbstraction constructor). There is no default value for the pointer
    class. Thus <i>b</i> is declared constant the used macro is P2CONST, not
    P2VAR. If you want to create a pointer to pointer (to pointer and so on) it
    is strongly recommended that you create a type of each pointer to avoid
    nesting of compiler abstraction macros.
</p>
<pre>
    Ptr&lt;SInt32&gt; p2b = new Ptr&lt;SInt32&gt;( "p2b", b );
    p2b.setCompilerAbstraction( new CompilerAbstraction( false, "AUTOMATIC", "AUTOMATIC" ) );

    cdsFile.var( p2b );

=   /**
=    * p2b
=    */
=   P2CONST( sint32, AUTOMATIC, AUTOMATIC ) p2b = &b;
</pre>

<h4>Null pointer</h4>
<p>
    A pointer needs a prototype of the reference to determine the type for
    itself. While creating a pointer to a non-null object the prototype is (of
    course) the reference itself and it is needless to define it twice. In case
    of a null pointer the reference is null and the prototype has to be defined.
    Note that the prototype needs no name. The value is also irrelevant for the
    creation of the pointer and is only necessary to fit the constructor of
    UInt16 (or any other primitive built-in types) that always requires a value.
</p>
<pre>
    cdsFile.var( new Ptr&lt;UInt16&gt;( "nullPointer", new UInt16( 0 ), null ) );

=   /**
=    * nullPointer
=    */
=   uint16 *nullPointer = NULL_PTR;
</pre>

<h4>Function pointer</h4>
<p>
    The Function class takes some kind of extraordinary place in the CType class
    structure and it's possibilities are very restricted. It is not supported to
    generate code for the function itself, not even a declaration. The only use
    case of a function is to generate function pointers whereas the referenced
    function is defined elsewhere. So a function only have to know the name,
    parameters (possibly void) and the result type. The rest of the pointer
    creation is very similar to the examples above.
</p>
<pre>
    Function getMax = new Function( "getMax", new CType[]{new SInt32( 0 ), new SInt32( 0 )}, new SInt32( 0 ) );

    Ptr&lt;Function&gt; p2max = new Ptr&lt;Function&gt;( "p2max", getMax );
    p2max.setComment( "This is a function pointer to function getMax( sint32, sint32 )" );

    cdsFile.var( p2max );

=   /**
=    * p2max
=    */
=   sint32 ( *p2max )( sint32, sint32 ) = &getMax; /* This is a function pointer to function getMax( sint32, sint32 ) */
</pre>

<h4>Post-build pointer</h4>
<p>
    The post-buildable pointer PBPtr is characterized by special compiler
    abstraction and assignment macros. It can not be subclassed so it is only
    allowed to generate variables of it. This example also shows how to obtain
    an element of an array. Thus <i>int2d</i> is a 2-dimensional array the first
    result of get is the array at index 0 and the second is the UInt8 at index
    3.
</p>
<pre>
    cdsFile.var( new PBPtr&lt;UInt8&gt;( "somePBPointer", int2d.get( 0 ).get( 3 ) ).setComment( "Pointing into array" ) );

=   /**
=    * somePBPointer
=    */
=   TS_REF2CFG( uint8 ) somePBPointer = TS_MAKEREF2CFG( i2d[0][3] ); /* Pointing into array */
</pre>

<h4>Writing some typedefs</h4>
<p>
    To create a typedef it is necessary to subclass the relevant built-in type
    that can be one of the primitive types (SInt8, SInt16,...), the Struct or
    the Ptr class. Furthermore it is possible to subclass your subclasses again
    and again to create typedefs of your already defined types. The name of the
    new type is the simple class name (without package) of your class.
    CDSGenFile provides methods type(CType) and type(CType, boolean) to write a
    typedef for the given type. Saying true to the second method will also write
    typedefs of superclasses and fields of the given class that are not built-in
    and not yet defined by previous typedefs in the same CDSGenFile. This
    feature is disabled (false) per default.
</p>

<h4>Typedef of an integer</h4>
<p>
    This example first shows class Number that extends the built-in type SInt16.
    First it implements every constructor of the superclass. The default
    constructor is protected in class SInt16 so it was not visible so far but
    can be made public here to alleviate the creation of a Number for the
    typedef. This case never needs a value nor a (variable) name. The name of
    the type is always the class name, in this case Number. This example also
    shows that method init() is called at the end of each constructor. This call
    is obligatory for some types (e.g. Struct) and it is best practice to
    perform it in every constructor. As the example shows you can override init
    to define properties and initial values for your class. Note that a compiler
    abstraction must be defined for the typedef and can not be changed when
    generating variables of it. This behaviour differs completely from built-in
    types.
</p>
<pre>
    public class Number extends SInt16 {

        /**
         * Constructor only used for typedef.
         */
        public Number() {
            super();
            init();
        }

        public Number( long value ) {
            super( value );
            init();
        }

        public Number( String name, long value ) {
            super( name, value );
            init();
        }

        protected void init() {
            super.init();
            setCompilerAbstraction( new CompilerAbstraction( false ) );
        }
    }


    // call to CDSGenFile.type(CType) somewhere in your generator...
    cdsFile.type( new Number() );

=   /**
=    * Number
=    */
=   typedef VAR( sint16, AUTOMATIC ) Number;
</pre>

<h4>Typedef of a Struct</h4>
<p>
    The next example shows struct Point that declares the members x and y. Any
    public CType field is assumed to be a member of the struct and any other
    field will be silently ignored. As the comment of x says it is best
    practice to declare members final to avoid reassignment unless you want it
    to be generated with the volatile modifier. It is necessary to call Struct's
    init() method at end of the constructor to set name and enclosing type to
    the members.
</p>
<pre>
    public class Point extends Struct {
        /**
         * x of this point. It is safe to declare the members final. If you would change the instance after init()
         * was called the member would loose its enclosing type!
         */
        public final SInt32 x = new SInt32( 0 );

        /**
         * y of this point.
         */
        public final SInt32 y = new SInt32( 0 );

        /**
         * Creates a new Point. This constructor is used when the point is a member of an enclosing type.
         */
        public Point() {
            super();
            init(); // per convention call method init at end of constructor!
        }

        /**
         * Create a new Point using the given name as variable name. This constructor is used for standalone vars.
         *
         * &#64;param name the name.
         */
        public Point( String name ) {
            super( name );
            init(); // per convention call method init at end of constructor!
        }
    }


    cdsFile.type( new Point() );

=   /**
=    * Point
=    */
=   typedef struct {
=       sint32 x; /* x */
=       sint32 y; /* y */
=   } Point;
</pre>

<h4>Typedef of a Pointer</h4>
<p>
    This example creates a typedef for MyPtr that is a pointer to UInt16.
</p>
<pre>
    public class MyPtr extends Ptr&lt;UInt16&gt; {
        /**
         * Only for typedefs.
         */
        public MyPtr() {
            super( new UInt16( 0 ) );
            init();
        }

        public MyPtr( UInt16 reference ) {
            super( reference );
            init();
        }

        public MyPtr( String name, UInt16 reference ) {
            super( name, reference );
            init();
        }

        public MyPtr( UInt16 refPrototype, UInt16 reference ) {
            super( refPrototype, reference );
            init();
        }

        public MyPtr( String name, UInt16 refPrototype, UInt16 reference ) {
            super( name, refPrototype, reference );
            init();
        }
    }


    cdsFile.type( new MyPtr() );

=   /**
=    * MyPtr
=    */
=   typedef uint16 *MyPtr;
</pre>

<h4>Subclassing pointer MyPtr</h4>
<p>
    It is allowed to subclass any own type again and again. Note that pointer
    ExtMyPtr is not a pointer to MyPtr but just another name for the same type,
    finally a pointer to UInt16. This example also demonstrates the usage of
    method CDSGenFile.type(CType, boolean) with parameter considerReferences set
    to true. Assumed that superclass MyPtr has not been defined yet in the same
    CDSGenFile it will be generated first.
</p>
<pre>
    public class ExtMyPtr extends MyPtr {
        /**
         * Only for typedefs.
         */
        public ExtMyPtr() {
            super();
            init();
        }

        public ExtMyPtr( UInt16 reference ) {
            super( reference );
            init();
        }

        public ExtMyPtr( String name, UInt16 reference ) {
            super( name, reference );
            init();
        }

        public ExtMyPtr( UInt16 refPrototype, UInt16 reference ) {
            super( refPrototype, reference );
            init();
        }

        public ExtMyPtr( String name, UInt16 refPrototype, UInt16 reference ) {
            super( name, refPrototype, reference );
            init();
        }
    }


    cdsFile.type( new ExtMyPtr(), true );

=   /**
=    * MyPtr
=    */
=   typedef uint16 *MyPtr;
=
=   /**
=    * ExtMyPtr
=    */
=   typedef MyPtr ExtMyPtr;
</pre>

<h4>Typedef pointer to MyPtr with compiler abstraction</h4>
<p>
    The next example demonstrates how to create a pointer to pointer MyPtr. This
    approach is strongly recommended when using compiler abstraction to avoid
    nesting of macros which often results in invalid C code.
</p>
<pre>
    public class P2MyPtr extends Ptr&lt;MyPtr&gt; {

        public P2MyPtr() {
            super( new MyPtr() );
            init();
        }

        public P2MyPtr( MyPtr reference ) {
            super( reference );
            init();
        }

        public P2MyPtr( String name, MyPtr reference ) {
            super( name, reference );
            init();
        }

        public P2MyPtr( MyPtr refPrototype, MyPtr reference ) {
            super( refPrototype, reference );
            init();
        }

        public P2MyPtr( String name, MyPtr refPrototype, MyPtr reference ) {
            super( name, refPrototype, reference );
            init();
        }

        protected void init() {
            super.init();
            setCompilerAbstraction( new CompilerAbstraction( true, "AUTOMATIC", "SOME_PTR_CLASS" ) );
        }
    }


    cdsFile.type( new P2MyPtr() );

=   /**
=    * P2MyPtr
=    */
=   typedef CONSTP2VAR( MyPtr, AUTOMATIC, SOME_PTR_CLASS ) P2MyPtr;
</pre>

<h4>Extending struct Point</h4>
<p>
    This example creates a 3d point with x, y and z members that inherits the
    x and y members from its superclass Point which was declared before.
    As we all know the C language doesn't support inheritance and actually the
    type Point3d has nothing to do with Point. So this is more a nice feature
    than a requirement to generate C code. But there is a second possible result
    when extending a type of struct. If the subclass doesn't declare further
    members then the type call doesn't generate the struct body again but
    results in the simple form "typedef Superclass Class;".
</p>
<pre>
    public class Point3d extends Point {
        /**
         * z-axis of this point.
         */
        public final SInt32 z = new SInt32( 0 );

        public Point3d() {
            init(); // per convention call method init at end of constructor!
        }

        public Point3d( String name ) {
            super( name );
            init(); // per convention call method init at end of constructor!
        }
    }


    cdsFile.type( new Point3d() );

=   /**
=    * Point3d
=    */
=   typedef struct {
=       sint32 x; /* x */
=       sint32 y; /* y */
=       sint32 z; /* z */
=   } Point3d;
</pre>

<h4>Typedef of struct with members of Point</h4>
<p>
    The following example shortly attests the ability to use self-defined types
    within a struct.
</p>
<pre>
    public class Rectangle extends Struct {
    
        public final Point pointA = new Point();
        public final Point pointB = new Point();
    
        public Rectangle() {
            init(); // per convention call method init at end of constructor!
        }

        public Rectangle( String name ) {
            super( name );
            init(); // per convention call method init at end of constructor!
        }
    }


    cdsFile.type( new Rectangle() );

=   /**
=    * Rectangle
=    */
=   typedef struct {
=       Point pointA; /* pointA */
=       Point pointB; /* pointB */
=   } Rectangle;
</pre>

<h4>Write variables of self-defined types</h4>
<p>
    Write variable mainWindow of previously defined type Rectangle. Thus the
    members are declared final (this is the recommended way) the properties can
    only be changed by the setter methods. Another approach to set values could
    be to require the members as parameters of your constructor.
</p>
<pre>
    Rectangle rect = new Rectangle( "mainWindow" );
    rect.pointA.x.setValue( 89 ).setComment( "This is the x-coordinate of point A. (explicit comment)" );
    rect.pointA.y.setValue( 45 );
    rect.pointB.setComment( "now follows point b." );
    rect.pointB.x.setValue( 101 );
    rect.pointB.y.setValue( 77 );

    cdsFile.var( rect );

=   /**
=    * mainWindow
=    */
=   Rectangle mainWindow = {
=       { /* pointA */
=           SINT32_C( 89 ), /* This is the x-coordinate of point A. (explicit comment) */
=           SINT32_C( 45 )  /* y */
=       },
=       { /* now follows point b. */
=           SINT32_C( 101 ), /* x */
=           SINT32_C( 77 )  /* y */
=       }
=   };
</pre></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../../dreisoft/tresos/generator/ng/api/ant/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../../dreisoft/tresos/generator/ng/api/cds/abstraction/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../../index.html?dreisoft/tresos/generator/ng/api/cds/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
